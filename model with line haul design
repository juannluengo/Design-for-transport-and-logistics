import pandas as pd
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
import numpy as np
import random
import gurobipy as gp
from gurobipy import GRB
from scipy.spatial.distance import cdist

# Caricamento dei dati e visualizzazione dei punti di ritiro e consegna per il distretto A
coordinates_districtA = pd.read_csv("/Users/dailagencarelli/Documents/Design4Transport&Logistic/instance_set/Set A/A1_1500_1.csv")
pickup_coordsA = coordinates_districtA.iloc[:500]
delivery_coordsA = coordinates_districtA.iloc[1500:2000]
plt.figure(figsize=(10,6))
plt.scatter(pickup_coordsA['X'], pickup_coordsA['Y'], color='blue', label='Pickups')
plt.scatter(delivery_coordsA['X'], delivery_coordsA['Y'], color='red', label='Deliveries')
plt.title("Coordinates district A")
plt.grid(True)
plt.legend()
plt.show()

# Caricamento dei dati e visualizzazione dei punti di ritiro e consegna per il distretto B
coordinates_districtB = pd.read_csv("/Users/dailagencarelli/Documents/Design4Transport&Logistic/instance_set/Set B/B1_1500_1.csv")
pickup_coordsB = coordinates_districtB.iloc[:500]
delivery_coordsB = coordinates_districtB.iloc[1500:2000]
# Traslazione del distretto B
translation_vector = np.array([300, 300])
coordinates_districtB[['X', 'Y']] = coordinates_districtB[['X', 'Y']] + translation_vector
plt.figure(figsize=(10,6))
plt.scatter(pickup_coordsB['X'], pickup_coordsB['Y'], color='blue', label='Pickups')
plt.scatter(delivery_coordsB['X'], delivery_coordsB['Y'], color='red', label='Deliveries')
plt.title("Coordinates district B")
plt.grid(True)
plt.legend()
plt.show()

# Funzione per calcolare l'Elbow curve
def calculate_elbow(data, k_range):
    inertias = []
    for k in k_range:
        kmeans = KMeans(n_clusters=k)
        kmeans.fit(data)
        inertias.append(kmeans.inertia_)
    return inertias

# Funzione per visualizzare l'Elbow curve
def plot_elbow(inertias, k_range, title):
    plt.figure(figsize=(8, 4))
    plt.plot(k_range, inertias, '-o')
    plt.title(title)
    plt.xlabel('Number of Clusters (k)')
    plt.ylabel('Sum of Squared Distances')
    plt.grid(True)
    plt.show()

# Funzione per visualizzare i cluster con satelliti e hub
def plot_clusters_with_hubs_satellites(data, centroids, satellite_locations, hub_locations, labels, title):
    plt.figure(figsize=(10, 6))
    plt.scatter(data.iloc[:, 0], data.iloc[:, 1], c=labels, cmap='viridis', alpha=0.5)
    plt.scatter([loc[0] for loc in satellite_locations], [loc[1] for loc in satellite_locations], c='red', marker='x', s=100, label='Potential Satellites')
    plt.scatter([loc[0] for loc in hub_locations], [loc[1] for loc in hub_locations], c='blue', marker='o', s=100, label='Potential Hubs')
    plt.title(title)
    plt.xlabel('X')
    plt.ylabel('Y')
    plt.grid(True)
    plt.legend()
    plt.show()

# Generazione dei potenziali hub per il distretto A e B
num_hubs_per_cluster = 50
def generate_random_hub_locations(centroids, num_hubs_per_cluster):
    hub_locations = []
    for center in centroids:
        for _ in range(num_hubs_per_cluster):
            hub_x = random.uniform(center[0] - 25, center[0] + 25)  
            hub_y = random.uniform(center[1] - 25, center[1] + 25)  
            hub_locations.append((hub_x, hub_y))
    return hub_locations

# Generazione dei potenziali satelliti per il distretto A e B
num_satellites_per_cluster = 100
def generate_random_satellite_locations(centroids, num_satellites_per_cluster):
    satellite_locations = []
    for center in centroids:
        for _ in range(num_satellites_per_cluster):
            sat_x = random.uniform(center[0] - 25, center[0] + 25)  
            sat_y = random.uniform(center[1] - 25, center[1] + 25)  
            satellite_locations.append((sat_x, sat_y))
    return satellite_locations

# Calcolo dell'Elbow curve per il distretto A
k_range_A = range(1, 21)
inertias_A = calculate_elbow(coordinates_districtA[['X', 'Y']], k_range_A)
plot_elbow(inertias_A, k_range_A, title='Elbow Method for optimal clusters in District A')

# Calcolo dell'Elbow curve per il distretto B
k_range_B = range(1, 21)
inertias_B = calculate_elbow(coordinates_districtB[['X', 'Y']], k_range_B)
plot_elbow(inertias_B, k_range_B, title='Elbow Method for optimal clusters in District B')

# Clustering per il distretto A
k_optimal_districtA = 4
kmeans_A = KMeans(n_clusters=k_optimal_districtA)
kmeans_A.fit(coordinates_districtA[['X', 'Y']])
centroids_A = kmeans_A.cluster_centers_
labels_A = kmeans_A.labels_
satellite_locations_A = generate_random_satellite_locations(centroids_A, num_satellites_per_cluster)
hub_locations_A = generate_random_hub_locations(centroids_A, num_hubs_per_cluster)
plot_clusters_with_hubs_satellites(coordinates_districtA[['X', 'Y']], centroids_A, satellite_locations_A, hub_locations_A, labels_A, title='Clusters with Satellites and Hubs for District A')

# Clustering per il distretto B
k_optimal_districtB = 4
kmeans_B = KMeans(n_clusters=k_optimal_districtB)
kmeans_B.fit(coordinates_districtB[['X', 'Y']])
centroids_B = kmeans_B.cluster_centers_
labels_B = kmeans_B.labels_
satellite_locations_B = generate_random_satellite_locations(centroids_B, num_satellites_per_cluster)
hub_locations_B = generate_random_hub_locations(centroids_B, num_hubs_per_cluster)
plot_clusters_with_hubs_satellites(coordinates_districtB[['X', 'Y']], centroids_B, satellite_locations_B, hub_locations_B, labels_B, title='Clusters with Satellites and Hubs for District B')

# Funzione per calcolare le distanze euclidee
def calculate_distances(set1, set2):
    distances = cdist(set1, set2, 'euclidean')
    return distances

# Calcolo delle distanze
# Calcolo delle distanze
dist_pickupsA_satellitesA = calculate_distances(pickup_coordsA[['X', 'Y']], satellite_locations_A[:num_satellites_per_cluster * k_optimal_districtA])
dist_satellitesA_hubA = calculate_distances(satellite_locations_A[:num_satellites_per_cluster * k_optimal_districtA], hub_locations_A[:num_hubs_per_cluster * k_optimal_districtA])
dist_hubA_hubB = calculate_distances(hub_locations_A[:num_hubs_per_cluster * k_optimal_districtA], hub_locations_B[:num_hubs_per_cluster * k_optimal_districtB])
dist_hubB_satellitesB = calculate_distances(hub_locations_B[:num_hubs_per_cluster * k_optimal_districtB], satellite_locations_B[:num_satellites_per_cluster * k_optimal_districtB])
dist_satellitesB_deliveriesB = calculate_distances(satellite_locations_B[:num_satellites_per_cluster * k_optimal_districtB], delivery_coordsB[['X', 'Y']])
dist_pickupsB_satellitesB = calculate_distances(pickup_coordsB[['X', 'Y']], satellite_locations_B[:num_satellites_per_cluster * k_optimal_districtB])
dist_satellitesB_hubB = calculate_distances(satellite_locations_B[:num_satellites_per_cluster * k_optimal_districtB], hub_locations_B[:num_hubs_per_cluster * k_optimal_districtB])
dist_hubA_satellitesA = calculate_distances(hub_locations_A[:num_hubs_per_cluster * k_optimal_districtA], satellite_locations_A[:num_satellites_per_cluster * k_optimal_districtA])
dist_hubB_hubA = dist_hubA_hubB.T  # Transpose delle distanze tra hubA e hubB per ottenere hubB a hubA
dist_satellitesA_deliveriesA = calculate_distances(satellite_locations_A[:num_satellites_per_cluster * k_optimal_districtA], delivery_coordsA[['X', 'Y']])


# Modello di ottimizzazione
m = gp.Model()

num_customers_per_district = 500
capacity_truck = 100
capacity_bike = 10

# Variabili binarie per nodi, hub e satelliti per il distretto A
x_A = m.addVars(num_customers_per_district, num_satellites_per_cluster * k_optimal_districtA, vtype=GRB.BINARY, name="x_A")
w_A = m.addVars(num_satellites_per_cluster * k_optimal_districtA, num_hubs_per_cluster * k_optimal_districtA, vtype=GRB.BINARY, name="w_A")
z_A = m.addVars(num_hubs_per_cluster * k_optimal_districtA, num_customers_per_district, vtype=GRB.BINARY, name="z_A")

# Variabili binarie per nodi, hub e satelliti per il distretto B
x_B = m.addVars(num_customers_per_district, num_satellites_per_cluster * k_optimal_districtB, vtype=GRB.BINARY, name="x_B")
w_B = m.addVars(num_satellites_per_cluster * k_optimal_districtB, num_hubs_per_cluster * k_optimal_districtB, vtype=GRB.BINARY, name="w_B")
z_B = m.addVars(num_hubs_per_cluster * k_optimal_districtB, num_customers_per_district, vtype=GRB.BINARY, name="z_B")

# Variabili binarie per l'utilizzo di hub tra i distretti
y_AB = m.addVars(num_hubs_per_cluster * k_optimal_districtA, num_hubs_per_cluster * k_optimal_districtB, vtype=GRB.BINARY, name="y_AB")

# Funzione obiettivo
m.setObjective(
    gp.quicksum(dist_pickupsA_satellitesA[i, j] * x_A[i, j] for i in range(num_customers_per_district) for j in range(num_satellites_per_cluster * k_optimal_districtA)) +
    gp.quicksum(dist_satellitesA_hubA[j, k] * w_A[j, k] for j in range(num_satellites_per_cluster * k_optimal_districtA) for k in range(num_hubs_per_cluster * k_optimal_districtA)) +
    gp.quicksum(dist_hubA_hubB[k, l] * y_AB[k, l] for k in range(num_hubs_per_cluster * k_optimal_districtA) for l in range(num_hubs_per_cluster * k_optimal_districtB)) +
    gp.quicksum(dist_hubB_satellitesB[l, m] * w_B[l, m] for l in range(num_hubs_per_cluster * k_optimal_districtB) for m in range(num_satellites_per_cluster * k_optimal_districtB)) +
    gp.quicksum(dist_satellitesB_deliveriesB[m, n] * x_B[m, n] for m in range(num_satellites_per_cluster * k_optimal_districtB) for n in range(num_customers_per_district)) +
    gp.quicksum(dist_pickupsB_satellitesB[i, j] * x_B[i, j] for i in range(num_customers_per_district) for j in range(num_satellites_per_cluster * k_optimal_districtB)) +
    gp.quicksum(dist_satellitesB_hubB[j, k] * w_B[j, k] for j in range(num_satellites_per_cluster * k_optimal_districtB) for k in range(num_hubs_per_cluster * k_optimal_districtB)) +
    gp.quicksum(dist_hubA_satellitesA[k, m] * z_A[k, m] for k in range(num_hubs_per_cluster * k_optimal_districtA) for m in range(num_customers_per_district)) +
    gp.quicksum(dist_hubB_hubA[l, k] * y_AB[l, k] for l in range(num_hubs_per_cluster * k_optimal_districtB) for k in range(num_hubs_per_cluster * k_optimal_districtA)) +
    gp.quicksum(dist_satellitesA_deliveriesA[m, n] * x_A[m, n] for m in range(num_satellites_per_cluster * k_optimal_districtA) for n in range(num_customers_per_district)),
    GRB.MINIMIZE)

# Vincoli di capacità per i satelliti del distretto A
for j in range(num_satellites_per_cluster * k_optimal_districtA):
    m.addConstr(gp.quicksum(x_A[i, j] for i in range(num_customers_per_district)) <= capacity_bike)

# Vincoli di capacità per i hub del distretto A
for k in range(num_hubs_per_cluster * k_optimal_districtA):
    m.addConstr(gp.quicksum(w_A[j, k] for j in range(num_satellites_per_cluster * k_optimal_districtA)) <= capacity_truck)

# Vincoli di capacità per i satelliti del distretto B
for j in range(num_satellites_per_cluster * k_optimal_districtB):
    m.addConstr(gp.quicksum(x_B[i, j] for i in range(num_customers_per_district)) <= capacity_bike)

# Vincoli di capacità per i hub del distretto B
for k in range(num_hubs_per_cluster * k_optimal_districtB):
    m.addConstr(gp.quicksum(w_B[j, k] for j in range(num_satellites_per_cluster * k_optimal_districtB)) <= capacity_truck)

# Vincoli di assegnazione clienti-satelliti nel distretto A
for i in range(num_customers_per_district):
    m.addConstr(gp.quicksum(x_A[i, j] for j in range(num_satellites_per_cluster * k_optimal_districtA)) == 1)

# Vincoli di assegnazione clienti-satelliti nel distretto B
for i in range(num_customers_per_district):
    m.addConstr(gp.quicksum(x_B[i, j] for j in range(num_satellites_per_cluster * k_optimal_districtB)) == 1)

# Vincoli di assegnazione satelliti-hub nel distretto A
for j in range(num_satellites_per_cluster * k_optimal_districtA):
    m.addConstr(gp.quicksum(w_A[j, k] for k in range(num_hubs_per_cluster * k_optimal_districtA)) == 1)

# Vincoli di assegnazione satelliti-hub nel distretto B
for j in range(num_satellites_per_cluster * k_optimal_districtB):
    m.addConstr(gp.quicksum(w_B[j, k] for k in range(num_hubs_per_cluster * k_optimal_districtB)) == 1)

# Vincoli di assegnazione hub-hub tra i distretti
for k in range(num_hubs_per_cluster * k_optimal_districtA):
    m.addConstr(gp.quicksum(y_AB[k, l] for l in range(num_hubs_per_cluster * k_optimal_districtB)) <= 1)

for l in range(num_hubs_per_cluster * k_optimal_districtB):
    m.addConstr(gp.quicksum(y_AB[k, l] for k in range(num_hubs_per_cluster * k_optimal_districtA)) <= 1)

# Ottimizzazione
m.optimize()

# Estrazione delle soluzioni
solution_x_A = m.getAttr('x', x_A)
solution_w_A = m.getAttr('x', w_A)
solution_z_A = m.getAttr('x', z_A)
solution_x_B = m.getAttr('x', x_B)
solution_w_B = m.getAttr('x', w_B)
solution_z_B = m.getAttr('x', z_B)
solution_y_AB = m.getAttr('x', y_AB)

# Funzione per visualizzare la soluzione
def plot_solution(data, centroids, satellite_locations, hub_locations, labels, solution_x, solution_w, solution_z, solution_y, title):
    plt.figure(figsize=(10, 6))
    plt.scatter(data.iloc[:, 0], data.iloc[:, 1], c=labels, cmap='viridis', alpha=0.5)
    plt.scatter([loc[0] for loc in satellite_locations], [loc[1] for loc in satellite_locations], c='red', marker='x', s=100, label='Satellites')
    plt.scatter([loc[0] for loc in hub_locations], [loc[1] for loc in hub_locations], c='blue', marker='o', s=100, label='Hubs')
    for i in range(num_customers_per_district):
        for j in range(num_satellites_per_cluster * k_optimal_districtA):
            if solution_x[i, j] > 0.5:
                plt.plot([data.iloc[i, 0], satellite_locations[j][0]], [data.iloc[i, 1], satellite_locations[j][1]], 'k-', alpha=0.3)
    for j in range(num_satellites_per_cluster * k_optimal_districtA):
        for k in range(num_hubs_per_cluster * k_optimal_districtA):
            if solution_w[j, k] > 0.5:
                plt.plot([satellite_locations[j][0], hub_locations[k][0]], [satellite_locations[j][1], hub_locations[k][1]], 'r-', alpha=0.3)
    for k in range(num_hubs_per_cluster * k_optimal_districtA):
        for l in range(num_hubs_per_cluster * k_optimal_districtB):
            if solution_y[k, l] > 0.5:
                plt.plot([hub_locations[k][0], hub_locations[l][0]], [hub_locations[k][1], hub_locations[l][1]], 'b-', alpha=0.3)
    plt.title(title)
    plt.xlabel('X')
    plt.ylabel('Y')
    plt.grid(True)
    plt.legend()
    plt.show()

# Visualizzazione della soluzione per il distretto A
plot_solution(coordinates_districtA[['X', 'Y']], centroids_A, satellite_locations_A, hub_locations_A, labels_A, solution_x_A, solution_w_A, solution_z_A, solution_y_AB, "Soluzione per il distretto A")

# Visualizzazione della soluzione per il distretto B
plot_solution(coordinates_districtB[['X', 'Y']], centroids_B, satellite_locations_B, hub_locations_B, labels_B, solution_x_B, solution_w_B, solution_z_B, solution_y_AB, "Soluzione per il distretto B")
